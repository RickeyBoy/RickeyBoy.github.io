<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo.png"/>
	<link rel="shortcut icon" href="/img/logo.png">
	
			    <title>
    Diemension C-317
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Rickey Scarlett" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Dimension C-137</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Interview/">Interview</a></li><li><a class="category-link" href="/categories/Swift/">Swift</a></li><li><a class="category-link" href="/categories/Travelling/">Travelling</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/RickeyBoy" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Header_Protocol.png?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem;"><h2 >Swift Protocol 详解</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote>
<p>《 The Swift Programming Language 》</p>
</blockquote>
<h4 id="Protocol-基础语法"><a href="#Protocol-基础语法" class="headerlink" title="Protocol 基础语法"></a>Protocol 基础语法</h4><ol>
<li>属性要求 ： <ul>
<li>{ get set } ：指定读写属性</li>
<li>static／class：指定类型属性</li>
</ul>
</li>
<li>方法要求：<ul>
<li>static／class：指定类方法</li>
<li>mutating：要求实现可变方法（针对值类型的实例方法，可以在该方法中修改它所属的实例以及实例的任意属性的值）</li>
</ul>
</li>
<li>构造器要求：<ul>
<li>在遵循协议的类中，必须使用<code>required</code>关键字修饰，保证其子类也必须提供该构造器的实现。（除非有<code>final</code>修饰的类，可以不用<code>required</code>，因为不会再有子类）</li>
</ul>
</li>
</ol>
<h4 id="Protocol-作为类型"><a href="#Protocol-作为类型" class="headerlink" title="Protocol 作为类型"></a>Protocol 作为类型</h4><ol>
<li>作为类型：代表遵循了该协议的某个实例（实际上就是某个实例遵循了协议）</li>
<li>协议类型的集合：<code>let A: [someProtocol]</code>，遵守某个协议的实例的集合</li>
<li>Delegate 委托设计模式：定义协议来封装那些需要被委托的功能</li>
</ol>
<h4 id="Protocol-间的关系"><a href="#Protocol-间的关系" class="headerlink" title="Protocol 间的关系"></a>Protocol 间的关系</h4><ol>
<li>协议的继承：协议可继承</li>
<li>协议的合成：使用<code>&amp;</code>关键字，同时遵循多个协议</li>
<li>协议的一致性：使用<code>is</code>、<code>as？</code>、<code>as！</code>进行一致性检查</li>
<li>类专属协议：协议继承时使用<code>class</code>关键字，限制该协议职能被类继承</li>
</ol>
<h4 id="optional-amp-objc-关键字"><a href="#optional-amp-objc-关键字" class="headerlink" title="optional &amp; @objc 关键字"></a>optional &amp; @objc 关键字</h4><p>可选协议：使用<code>optional</code>修饰属性、函数、协议本身，同时所有<code>option</code>必须被<code>@objc</code>修饰，协议本身也必须使用<code>@objc</code>，只能被Objective-C的类或者<code>@objc</code>的类使用</p>
<h4 id="extension-关键字"><a href="#extension-关键字" class="headerlink" title="extension 关键字"></a>extension 关键字</h4><ul>
<li>（对实例使用）令已有类型遵循某个协议</li>
<li>（对协议使用）可遵循其他协议，增加协议一致性</li>
<li>（对协议使用）提供默认实现</li>
<li>（搭配<code>where</code>对协议使用）增加限制条件</li>
</ul>
<h2 id="Classes-类-特点和问题"><a href="#Classes-类-特点和问题" class="headerlink" title="Classes 类 - 特点和问题"></a>Classes 类 - 特点和问题</h2><blockquote>
<p>类（Class） 是面向对象编程之中的重要元素，它代表的是一个共享相同结构和行为的对象的集合</p>
</blockquote>
<ul>
<li>Classes 可以做的事：<ul>
<li>Encapsulation 封装：表现为对外提供接口，隐藏具体逻辑，保证类的高内聚</li>
<li>Access Control 访问控制：依赖于类的修饰符（如public、private），保证隔离性</li>
<li>Abstraction 抽象：提取具有类似特性的事物，进行建模</li>
<li>NameSpace 命名空间：避免不同作用域中，同名变量、函数发生冲突</li>
<li>Expressive Syntax 丰富的语法</li>
<li>Extensibility 可拓展性：可继承、可重写等等</li>
</ul>
</li>
</ul>
<h4 id="Classes-的问题："><a href="#Classes-的问题：" class="headerlink" title="Classes 的问题："></a>Classes 的问题：</h4><h5 id="1-Implicit-Sharing-隐式共享"><a href="#1-Implicit-Sharing-隐式共享" class="headerlink" title="1. Implicit Sharing 隐式共享:"></a>1. Implicit Sharing 隐式共享:</h5><p><img src="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Protocol/1.png?raw=true" width="200"></p>
<p>可能会导致大量保护性拷贝（Defensive Copy），导致效率降低；也有可能发生竞争条件（race condition），出现不可预知的错误；为了避免race condition，需要使用锁（Lock），但是这更会导致代码效率降低，并且有可能导致死锁（Dead Lock）</p>
<h5 id="2-Inheritance-All-全部继承："><a href="#2-Inheritance-All-全部继承：" class="headerlink" title="2. Inheritance All 全部继承："></a>2. Inheritance All 全部继承：</h5><p>由于继承时，子类将继承父类全部的属性，所以有可能导致子类过于庞大，逻辑过于复杂。尤其是当父类具有存储属性（stored properties）的时候，子类必须全部继承，并且小心翼翼得初始化，避免损坏父类中的逻辑。如果需要重写（override）父类的方法，则必须要小心思考如何重写以及何时重写。</p>
<h5 id="3-Lost-Type-Relationships-不能反应类型关系："><a href="#3-Lost-Type-Relationships-不能反应类型关系：" class="headerlink" title="3. Lost Type Relationships 不能反应类型关系："></a>3. Lost Type Relationships 不能反应类型关系：</h5><p><img src="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Protocol/2.jpeg?raw=true" width="300"></p>
<p>上图中，两个类（Label、Number）拥有相同的父类（Ordered），但是在 Number 中调用 Order 类必须要使用强制解析（as！）来判断 Other 的属性，这样做既不优雅，也非常容易出Bug（如果 Other 碰巧为Label类）</p>
<h2 id="Coupling-or-dependency-耦合性"><a href="#Coupling-or-dependency-耦合性" class="headerlink" title="Coupling or dependency 耦合性"></a>Coupling or dependency 耦合性</h2><blockquote>
<p>采用面向协议编程的方式，可以在一定程度上降低代码的耦合性。</p>
</blockquote>
<p>耦合性是一种软件度量，是指一程序中，模块及模块之间信息或参数依赖的程度。高耦合性将使得维护成本变高，同时降低代码可复用程度。低耦合性是结构良好程序的特性，低耦合性程序的可读性及可维护性会比较好。</p>
<h5 id="耦合级别"><a href="#耦合级别" class="headerlink" title="耦合级别"></a>耦合级别</h5><p><img src="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Protocol/3.jpeg?raw=true" width="300"></p>
<p>图示是耦合程度由高到低，可粗略分为五个级别：</p>
<ul>
<li><strong>Content coupling</strong> 内容耦合：又称病态耦合，一个模块直接使用另一个模块的内部数据。</li>
<li><strong>Common coupling</strong> 公共耦合：又称全局耦合，指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。</li>
<li><strong>Control coupling</strong> 控制耦合：指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能。</li>
<li><strong>Stamp coupling</strong> 特征耦合/标记耦合：又称数据耦合，几个模块共享一个复杂的数据结构。</li>
<li><strong>Data coupling</strong> 数据耦合：是指模块借由传入值共享数据，每一个数据都是最基本的数据，而且只分享这些数据（例如传递一个整数给计算平方根的函数）</li>
</ul>
<h5 id="高耦合性带来的问题"><a href="#高耦合性带来的问题" class="headerlink" title="高耦合性带来的问题"></a>高耦合性带来的问题</h5><ul>
<li>维护代价大：修改一个模块时可能产生<strong>涟漪效应</strong>，其他模块的内部逻辑也需要修改</li>
<li>结构不清晰：由于模块间依赖性太多，所以在模块的组合时需要消耗更多精力</li>
<li>可复用性低：每一个模块的依赖模块太多，导致可复用的程度降低</li>
</ul>
<h5 id="解耦-Dependency-Inversion-Principle-依赖反转原则"><a href="#解耦-Dependency-Inversion-Principle-依赖反转原则" class="headerlink" title="解耦 - Dependency Inversion Principle 依赖反转原则"></a>解耦 - Dependency Inversion Principle 依赖反转原则</h5><p>传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上，采用继承的方式实现。依赖反转原则（DIP）是指一种特定的解耦方式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p>
<p>DIP 规定：</p>
<ul>
<li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li>
<li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li>
</ul>
<p><img src="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Protocol/4.jpeg?raw=true" width="250"><br><img src="https://github.com/RickeyBoy/Rickey-iOS-Notes/blob/master/图床/Blog_Protocol/5.jpeg?raw=true" width="250"></p>
<p>举一个简单而经典的例子 – <strong>台灯和按钮</strong>。</p>
<p>第一幅图为传统的实现方式，依赖关系被创建直接在高层次对象（Button）上，当你需要改变低层次对象（Lamp）时，你必须要同时更改其父类（Button），如果此时有多个低层次的对象继承自父类（Button），那么更改其父类就变得十分困难。而第二幅图是符合DIP原则的方式，高层对象（Button）把需求抽象为一个抽象接口（ButtonServer），而具体实现（Lamp）依赖于这个抽象接口。同时，当需要实现多个底层对象时，只需要在具体实现时进行不同的实现即可。</p>
<h5 id="解耦-Protocol-Oriented-Programming-面向协议编程"><a href="#解耦-Protocol-Oriented-Programming-面向协议编程" class="headerlink" title="解耦 - Protocol Oriented Programming 面向协议编程"></a>解耦 - Protocol Oriented Programming 面向协议编程</h5><p>面向协议编程中，Protocol 实际上就是 DIP 中的抽象接口。通过之前的讲解，采用面向协议的方式进行编程，即是对依赖反转原则 DIP 的践行，在一定程度上<strong>降低代码的耦合性</strong>，避免耦合性过高带来的问题。下面通过一个具体实例简单讲解一下：</p>
<p>首先是高层次结构的实现，创建EmmettBrown的类，然后声明了一个需求（travelInTime方法）。</p>
<pre class="line-numbers language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 高层次实现 - EmmettBrown</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">EmmettBrown</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">let</span> timeMachine<span class="token punctuation">:</span> <span class="token builtin">TimeTraveling</span>
    <span class="token keyword">init</span><span class="token punctuation">(</span>timeMachine<span class="token punctuation">:</span> <span class="token builtin">TimeTraveling</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>timeMachine <span class="token operator">=</span> timeMachine
    <span class="token punctuation">}</span>
    <span class="token keyword">func</span> <span class="token function">travelInTime</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> timeMachine<span class="token punctuation">.</span><span class="token function">travelInTime</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> time<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>采用 Protocol 定义抽象接口 travelInTime，低层次的实现将需要依赖这个接口。</p>
<pre class="line-numbers language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 抽象接口 - 时光旅行</span>
protocol <span class="token builtin">TimeTraveling</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">travelInTime</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后是低层次实现，创建DeLorean类，通过遵循TimeTraveling协议，完成TravelInTime抽象接口的具体实现。</p>
<pre class="line-numbers language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 低层次实现 - DeLorean</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DeLorean</span><span class="token punctuation">:</span> <span class="token builtin">TimeTraveling</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function">travelInTime</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Used Flux Capacitor and travelled in time by: <span class="token interpolation"><span class="token delimiter variable">\(</span>time<span class="token delimiter variable">)</span></span>s"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用的时候只需要创建相关类即可调用其方法。</p>
<pre class="line-numbers language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 使用方式</span>
<span class="token keyword">let</span> timeMachine <span class="token operator">=</span> <span class="token function">DeLorean</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> mastermind <span class="token operator">=</span> <span class="token function">EmmettBrown</span><span class="token punctuation">(</span>timeMachine<span class="token punctuation">:</span> timeMachine<span class="token punctuation">)</span>
mastermind<span class="token punctuation">.</span><span class="token function">travelInTime</span><span class="token punctuation">(</span>time<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">3600</span> <span class="token operator">*</span> <span class="token number">8760</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">WWDC - Protocol-Oriented Programming in Swift</a></li>
<li><a href="https://github.com/ochococo/OOD-Principles-In-Swift">Github - OOD-Principles-In-Swift</a></li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'rickeyandscarlett'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://github.com/RickeyBoy/2017/10/15/Swift Protocol 详解/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://github.com/RickeyBoy/2017/10/15/Swift Protocol 详解/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//rickeyandscarlett.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
